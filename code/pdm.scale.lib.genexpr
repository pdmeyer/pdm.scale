// Validates that a scale intervals buffer is properly ordered
// Parameters:
//   buffer: Buffer containing scale intervals in semitones from root
// Returns: 1 if intervals are in ascending order, 0 if not
validate_intervals(buffer) {
    valid = 1;
    // Check each interval to ensure it's greater than or equal to the previous one
    if(peek(buffer, 0) != 0) {
        valid = 0;
    } else {
        for(i = 1; i < dim(buffer); i+=1) {
            diff = peek(buffer, i) - peek(buffer, i-1);
            if(diff < 0) {
                valid = 0;
                break;
            }
        }
    }
    return valid;
}

// Fits an input MIDI note to the nearest note in a specified scale
// Parameters:
//   note: Input MIDI note number (0-127)
//   intervals_buf: Buffer containing scale intervals in semitones from root (must be sorted ascending)
//   root_note: Root note of the scale (0-11, where 0=C, 1=C#, etc.)
//   previous_note: Previous note for context in rounding decisions
// Returns: fitted_note, scale_index (the fitted MIDI note and its scale degree index)
fit(note, intervals_buf, root_note, previous_note, round_mode) {
    //round_modes: 0 = down, 1 = up, 2 = nearest, 3 = smart

    done = 0;
    // Standard 12-tone equal temperament
    steps_per_octave = 12;

    // Clamp input note to valid MIDI range (0-127) and convert to integer
    input_note = max(0, min(127, floor(note)));
    
    // Convert input note to chromatic value 0 - 11
    chromatic = wrap(input_note, 0, steps_per_octave);

    fitted_note = -1;
    scale_degree = -1;

    if(chromatic == root_note) {
        done = 1;
        fitted_note = input_note;
        scale_degree = 0;
    }
    
    if(!done) {
        fitted_scale_deg = -1;
        fitted_scale_interval = -1;
        root_relative = wrap(chromatic - root_note, 0, steps_per_octave);
        length = dim(intervals_buf);

        for(i = 1; i < length; i+=1) {
            scale_interval = peek(intervals_buf, i);

            //check if note is already in scale
            if(scale_interval == root_relative) {
                done = 1;
                fitted_note = input_note;
                scale_degree = i;
                break;

            //if note insn't in scale, fall back to previous scale degree
            } else if (scale_interval > root_relative) {
                rm  = floor(round_mode);
                //round down
                if(rm == 0) {
                    fitted_scale_deg = i - 1;
                    fitted_scale_interval = peek(intervals_buf, fitted_scale_deg);
                //round up
                } else if(rm == 1) {
                    fitted_scale_deg = i;
                    fitted_scale_interval = peek(intervals_buf, fitted_scale_deg);
                //round to nearest note
                } else if(rm == 2) {
                    previous_interval = peek(intervals_buf, i - 1);
                    prev_distance = abs(previous_interval - root_relative);
                    curr_distance = abs(scale_interval - root_relative);
                    fitted_scale_interval = prev_distance <= curr_distance ? previous_interval : scale_interval;
                //"smart" - round down unless the input note is 1 semitone above the previous note
                } else if(rm == 3) {
                    fitted_scale_deg = input_note - previous_note == 1 ? i : i - 1;
                    fitted_scale_interval = peek(intervals_buf, fitted_scale_deg);
                }

                fit_diff = fitted_scale_interval - root_relative;
                done = 1;
                fitted_note = input_note + fit_diff;
                scale_degree = fitted_scale_deg;
                break;
            }
        }

        if(!done) {
            // if note still hasn't been found, then it's between the last and first scale degrees
            rm = floor(round_mode);
            first = 0;
            last = length - 1;

            //round down
            if(rm == 0) {
                fitted_scale_deg = last;
            //round up
            } else if(rm == 1) {
                fitted_scale_deg = first;
            //round to nearest note
            } else if(rm == 2) {
                first_interval = peek(intervals_buf, first) + steps_per_octave; //should be 12
                last_interval = peek(intervals_buf, last);
                prev_distance = abs(last_interval - root_relative);
                curr_distance = abs(first_interval - root_relative);
                fitted_scale_deg = prev_distance <= curr_distance ? last : first;
            //"smart" - round down unless the input note is 1 semitone above the previous note
            } else if(rm == 3) {
                fitted_scale_deg = input_note - previous_note == 1 ? first : last;
            }

            fitted_scale_interval = peek(intervals_buf, fitted_scale_deg);
            fit_diff = fitted_scale_interval - root_relative;
            fitted_note = input_note + fit_diff;
            scale_degree = fitted_scale_deg;
        }
    }    
    return fitted_note, scale_degree;
}

// Transposes a note by a specified number of scale degrees
// Parameters:
//   note: Input MIDI note number (0-127)
//   amt: Number of scale degrees to transpose (can be negative)
//   intervals_buf: Buffer containing scale intervals in semitones from root
//   root_note: Root note of the scale (0-11)
//   previous_note: Previous note for context in fitting
//Returns: Transposed MIDI note number
// 

transpose_degrees(note, amt, intervals_buf, root_note, previous_note, round_mode) {
    steps_per_octave = 12;

    // First fit the input note to the scale
    // Also get the scale degree of the note, relative to the root
    ftd, fitted_deg = fit(note, intervals_buf, root_note, previous_note, round_mode);

	// convert amt to integer and clamp to prevent out-of-bounds transposition
    amt_ = max(0 - ftd, min(127 - ftd, floor(amt)));

    // if the amount is 0, return the fitted note
    xposed = ftd;
    xpose_deg = fitted_deg;
    scale_length = dim(intervals_buf);

    if(amt_ != 0 ) {
        //scale_length = dim(intervals_buf);
        // Calculate the interval for transposition
        xpose_deg = wrap(fitted_deg + amt_, 0, scale_length);

        fitted_step = peek(intervals_buf, fitted_deg);
        xpose_step = peek(intervals_buf, xpose_deg);
        relative_step = xpose_step - fitted_step;
        xpose_octaves = floor((fitted_deg + amt_) / scale_length);
        xpose_amt = relative_step + (xpose_octaves * steps_per_octave);
        xposed = ftd + xpose_amt;
    }
    return xposed, xpose_deg;
}

// Simple semitone transposition (chromatic transposition)
// Parameters:
//   note: Input MIDI note number (0-127)
//   semitones: Number of semitones to transpose (can be negative)
// Returns: Transposed MIDI note number
transpose_semitones(note, semitones) {
    return floor(note) + floor(semitones);
}
    

